from __future__ import annotations
from typing import Optional
from grams.core import AlgoContext
from grams.core.base import RustVecIter
from grams.core.literal_matchers import LiteralMatcher, ParsedTextRepr
from grams.core.table import LinkedTable

def matching(
    table: LinkedTable,
    table_cells: list[list[ParsedTextRepr]],
    context: AlgoContext,
    literal_matcher: LiteralMatcher,
    ignored_columns: list[str],
    ignored_props: list[str],
    allow_same_ent_search: bool,
    use_context: bool,
) -> DataMatchesResult: ...

class DataMatchesResult:
    def save(self, path: str) -> None: ...
    @staticmethod
    def load(path: str) -> DataMatchesResult: ...
    def iter_rels(self) -> RustVecIter[PotentialRelationships]: ...
    def is_cell_node(self, idx: int) -> bool: ...
    def get_cell_node(self, idx: int) -> CellNode: ...
    def is_entity_node(self, idx: int) -> bool: ...
    def get_entity_node(self, idx: int) -> EntityNode: ...

class CellNode:
    @property
    def col(self) -> int: ...
    @property
    def row(self) -> int: ...

class EntityNode:
    @property
    def entity_id(self) -> str: ...

class PotentialRelationships:
    @property
    def source_id(self) -> int: ...
    @property
    def target_id(self) -> int: ...
    def iter_rels(self) -> RustVecIter[MatchedEntRel]: ...

class MatchedEntRel:
    @property
    def source_entity_id(self) -> str: ...
    def iter_statements(self) -> RustVecIter[MatchedStatement]: ...

PP = property

class MatchedStatement:
    @PP
    def property(self) -> str: ...
    @PP
    def statement_index(self) -> int: ...
    @PP
    def property_matched_score(self) -> Optional[int]: ...
    def iter_qualifier_matched_scores(self) -> RustVecIter[MatchedQualifier]: ...

class MatchedQualifier:
    @property
    def qualifier(self) -> str: ...
    @property
    def qualifier_index(self) -> int: ...
    @property
    def matched_score(self) -> float: ...
